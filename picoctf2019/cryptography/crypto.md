### Rsa-pop-quiz

We can connect with nc:

Question 1:

```bash
nc 2019shell1.picoctf.com 53028
Good morning class! It's me Ms. Adleman-Shamir-Rivest
Today we will be taking a pop quiz, so I hope you studied. Cramming just will not do!
You will need to tell me if each example is possible, given your extensive crypto knowledge.
Inputs and outputs are in decimal. No hex here!
#### NEW PROBLEM ####
q : 60413
p : 76753
##### PRODUCE THE FOLLOWING ####
n
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

We have p and q and it ask if it is feasible to produce n, it is feasible because n=pq, we can calculate it with python:

```python
>>> p = 76753
>>> q = 60413
>>> print(p*q)
4636878989
```

Question 2:

```bash
#### NEW PROBLEM ####
p : 54269
n : 5051846941
##### PRODUCE THE FOLLOWING ####
q
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

Now we have the value of p and n and we have to calculate q, it is feasible, the equation to calculate n is n=p*q, so it's a simple equation: q=n/p:

```python
>>> p = 54269
>>> n = 5051846941
>>> print(n//p)
93089
```

Question 3:

```
#### NEW PROBLEM ####
e : 3
n : 12738162802910546503821920886905393316386362759567480839428456525224226445173031635306683726182522494910808518920409019414034814409330094245825749680913204566832337704700165993198897029795786969124232138869784626202501366135975223827287812326250577148625360887698930625504334325804587329905617936581116392784684334664204309771430814449606147221349888320403451637882447709796221706470239625292297988766493746209684880843111138170600039888112404411310974758532603998608057008811836384597579147244737606088756299939654265086899096359070667266167754944587948695842171915048619846282873769413489072243477764350071787327913
##### PRODUCE THE FOLLOWING ####
q
p
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

Now we have e and n, this isn't feasible because we cannot factor n.

Question 4:

```
#### NEW PROBLEM ####
q : 66347
p : 12611
##### PRODUCE THE FOLLOWING ####
totient(n)
```

It is feasible, we have to apply the formula: 

phi(n) = (p-1)*(q-1)

```python
>>> q = 66347
>>> p = 12611
>>> phi_n = (p-1)*(q-1)
>>> print(phi_n)
836623060
```

Question 5:

```
#### NEW PROBLEM ####
plaintext : 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717
e : 3
n : 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331
##### PRODUCE THE FOLLOWING ####
ciphertext
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

We are have to encrypt the plaintext and we have e and n, this is feasible we have to apply the formula:

c = m^e (mod n)

(NOTE: c is going to be the cipher, and m is the plaintext)

```python
>>> m = 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717
>>> e = 3
>>> n = 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331
>>> c = pow(m,e,n)
>>> print(c)
256931246631782714357241556582441991993437399854161372646318659020994329843524306570818293602492485385337029697819837182169818816821461486018802894936801257629375428544752970630870631166355711254848465862207765051226282541748174535990314552471546936536330397892907207943448897073772015986097770443616540466471245438117157152783246654401668267323136450122287983612851171545784168132230208726238881861407976917850248110805724300421712827401063963117423718797887144760360749619552577176382615108244813
```

Question 6:

```bash
#### NEW PROBLEM ####
ciphertext : 107524013451079348539944510756143604203925717262185033799328445011792760545528944993719783392542163428637172323512252624567111110666168664743115203791510985709942366609626436995887781674651272233566303814979677507101168587739375699009734588985482369702634499544891509228440194615376339573685285125730286623323
e : 3
n : 27566996291508213932419371385141522859343226560050921196294761870500846140132385080994630946107675330189606021165260590147068785820203600882092467797813519434652632126061353583124063944373336654246386074125394368479677295167494332556053947231141336142392086767742035970752738056297057898704112912616565299451359791548536846025854378347423520104947907334451056339439706623069503088916316369813499705073573777577169392401411708920615574908593784282546154486446779246790294398198854547069593987224578333683144886242572837465834139561122101527973799583927411936200068176539747586449939559180772690007261562703222558103359
##### PRODUCE THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

Now we have decrypt the ciphertext having e and n, this is not feasible as we don't have the d because the formula is this:

m = c^d (mod n)

Question 7:

```bash
#### NEW PROBLEM ####
q : 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
p : 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
e : 65537
##### PRODUCE THE FOLLOWING ####
d
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

In this question we have to calculate d with q,p and e, this is feasible, by calculating phi(n), and then calculate the modular inverse of e mod(phi(n))

```python
>>> from Crypto.Util.number import inverse
>>> q = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
>>> p = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
>>> e = 65537
>>> phi = (p-1)*(q-1)
>>> d = inverse(e,phi)
>>> print(d)
1405046269503207469140791548403639533127416416214210694972085079171787580463776820425965898174272870486015739516125786182821637006600742140682552321645503743280670839819078749092730110549881891271317396450158021688253989767145578723458252769465545504142139663476747479225923933192421405464414574786272963741656223941750084051228611576708609346787101088759062724389874160693008783334605903142528824559223515203978707969795087506678894006628296743079886244349469131831225757926844843554897638786146036869572653204735650843186722732736888918789379054050122205253165705085538743651258400390580971043144644984654914856729
```

Question 8:

```
#### NEW PROBLEM ####
p : 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
ciphertext : 3001133423508155019342391181454969453683740998389305521868482065953685989583037773702319581717484580966593370778920602258110457396723632087223210560766860657023257472172328220084386229851941678615818536289364033769762938914666434052719653085203028823631950908006150453932488069330802006070658787154818367594933024991778763357876382724018717890178006250599003585272226771381223645294365192346693302207328966906968620673419237444014642963102675933287390856161621142811266283239380789957372689818205738309791091491858305530388074249507780688913259911773093289575133704279048285836964311807507701403508531667913455534667
e : 65537
n : 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239
##### PRODUCE THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

This is also feasiable, we have to decode a ciphertext for this we have to use the formula:

m = c^d (modn)

To find d we need p,q,e. q can be found with q = n//p 

```python
>>> from Crypto.Util.number import inverse
>>> p = 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
>>> c = 3001133423508155019342391181454969453683740998389305521868482065953685989583037773702319581717484580966593370778920602258110457396723632087223210560766860657023257472172328220084386229851941678615818536289364033769762938914666434052719653085203028823631950908006150453932488069330802006070658787154818367594933024991778763357876382724018717890178006250599003585272226771381223645294365192346693302207328966906968620673419237444014642963102675933287390856161621142811266283239380789957372689818205738309791091491858305530388074249507780688913259911773093289575133704279048285836964311807507701403508531667913455534667
>>> e = 65537
>>> n = 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239
>>> q = n//p
>>> phi = (p-1)*(q-1)
>>> d = inverse(e,phi)
>>> m = pow(c,d,n)
>>> print(m)
14311663942709674867122208214901970650496788151239520971623411712977120619528460123336291453
```

Giving the answer it says:

```
If you convert the last plaintext to a hex number, then ascii, you'll find what you need! ;)
```

```python
>>> from Crypto.Util.number import long_to_bytes
>>> long_to_bytes(14311663942709674867122208214901970650496788151239520971623411712977120619528460123336291453)
b'picoCTF{wA8_th4t$_ill3aGal..of4878474}'
```

### MiniRSA

We have a file with this:

```
N: 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
e: 3

ciphertext (c): 2205316413931134031074603746928247799030155221252519872649604243394069216326314270624430181767863085854215545736160599718939066687544261205735290002239045830806570632200667142910415788763317978137702614731825117431700919216297401306846053
```

Here n is a small number, and if the modulo is shorter than m^e, the modulo doesn't affect so you can apply the formula without the modulo:

c = m^e mod(n) -> c = m^e -> c = e√m

```python
import gmpy2
from Crypto.Util.number import long_to_bytes

n = 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
e = 3
c = 2205316413931134031074603746928247799030155221252519872649604243394069216326314270624430181767863085854215545736160599718939066687544261205735290002239045830806570632200667142910415788763317978137702614731825117431700919216297401306846053

gmpy2.get_context().precision=2048
m = gmpy2.root(c,e)
print(long_to_bytes(m).decode())
```

### b00tl3gRSA2

We can connect with nc:

```bash
nc 2019shell1.picoctf.com 1723
c: 53035012558337074139617208184445341228577473158934502307972725630649813907545201040270941249400932977783886896797502803471503050366324518584912013035804779921521173645957524961768502257616008324345412942717640900257447809726899706166369231315188843908083656034311577568288338167025254257671382922044452866799
n: 77112546207259093097535987613536666431322294761413780381708946813796304457169194864136905813170059502704778698673328393882461954679599974422107101344295396534564021543095616279495592121986251934600929258732776646564453728589891742221731075826206571496450548291427108651564840174155103657217403514852155355271
e: 39859386534585181466532327027422190701855044590653420574801597300214590380869793326174555157040281607544243453259344685767769064447962658246842244306870168716080036741317849146897497720801010782589485212115287868784938174879337862714946371253262023187160857570514628009605588329968334098732109473714064349185
```

In the description of the callenge says that why don't we use d instead of e, e is usally 3 or 65537, so in this case d = 65537, we can apply the formula and get the flag:

m = c^d mod(n)

```python
c = 53035012558337074139617208184445341228577473158934502307972725630649813907545201040270941249400932977783886896797502803471503050366324518584912013035804779921521173645957524961768502257616008324345412942717640900257447809726899706166369231315188843908083656034311577568288338167025254257671382922044452866799
n = 77112546207259093097535987613536666431322294761413780381708946813796304457169194864136905813170059502704778698673328393882461954679599974422107101344295396534564021543095616279495592121986251934600929258732776646564453728589891742221731075826206571496450548291427108651564840174155103657217403514852155355271
e = 39859386534585181466532327027422190701855044590653420574801597300214590380869793326174555157040281607544243453259344685767769064447962658246842244306870168716080036741317849146897497720801010782589485212115287868784938174879337862714946371253262023187160857570514628009605588329968334098732109473714064349185

d = 65537

m = pow(c,d,n)
print(bytes.fromhex(format(m,"x")))
```
